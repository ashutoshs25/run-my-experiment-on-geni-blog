This experiment demonstrates Babel, a loop-avoiding routing protocol for mesh networks, non-mesh networks, and hybrid networks.

It should take about 60 minutes to run this experiment.

To reproduce this experiment on GENI, you will need an account on the [GENI Portal](http://groups.geni.net/geni/wiki/SignMeUp), and you will need to have [joined a project](http://groups.geni.net/geni/wiki/JoinAProject). You should have already [uploaded your SSH keys to the portal and know how to log in to a node with those keys](http://groups.geni.net/geni/wiki/HowTo/LoginToNodes). If you're not sure if you have those skills, you may want to try [Lab Zero](http://tinyurl.com/geni-labzero) first.

* Skip to [Results](#results)
* Skip to [Run my experiment](#runmyexperiment)


## Background

[Babel](https://www.irif.univ-paris-diderot.fr/~jch//software/babel/) is a routing protocol that is designed to work in wired networks as well as wireless mesh networks. It is a [distance-vector routing protocol](https://en.wikipedia.org/wiki/Distance-vector_routing_protocol) that prevents routing loops.

For more on Babel, see the following video presentation by Juliusz Chroboczek, creator of Babel, at the BattleMesh v8 event in August 2015:

<iframe width="560" height="315" src="https://www.youtube.com/embed/1zMDLVln3XM" frameborder="0" allowfullscreen></iframe>

(Here are the slides: [Babel doesn't care](http://battlemesh.org/BattleMeshV8/Agenda?action=AttachFile&do=get&target=babel-20150804.pdf))


## Results

First, we see how routes are added and updated dynamically as new nodes join the network:

<iframe width="420" height="315" src="https://www.youtube.com/embed/8AoTxeiDt84" frameborder="0" allowfullscreen></iframe>

([Also in GIF form](/blog/content/images/2016/08/babel-animation-build.gif))

We also note that although the underlying topology has loops, the routes are loop free. (In the video, the solid lines show installed routes from the point of view of one node; the dashed lines show routes that this node is aware of, but that are not installed.)

We also verify that the protocol can reroute around failures. When we bring one interface down, breaking several existing routes, we can see that new routes are found, so that all nodes remain reachable. Also, when we bring the interface back up, the more direct routes are recovered:

<iframe width="420" height="315" src="https://www.youtube.com/embed/u9Ay-1OLMSo" frameborder="0" allowfullscreen></iframe>

([Also in GIF form](/blog/content/images/2016/08/babel-animation.gif))

## Run my experiment

In the GENI Portal, create a slice and click on "Add Resources". In the "Choose RSpec" area, select "URL" and load the RSpec from the following [gist](https://gist.github.com/ffund/2cfee7e75dcddf6b2ba18ca94da75f28): [https://git.io/v6kqt](https://git.io/v6kqt)

This will load the following 7-node topology in your canvas:

![](/blog/content/images/2016/08/7-node-topo.png)

Click on "Site 1", select an InstaGENI site, and then reserve your resources. Wait for them to be ready to log in.

In the RSpec, we have set up a postboot script that will

1. install `babeld` and some other useful software on each node, and
2. remove the routes that are automatically generated by InstaGENI when you reserve resources. We will use Babel for routing, so we want each node to only have routes for its direct neighbors in its routing table.

You can see the postboot script [here](https://gist.github.com/ffund/41ca26a02eeb600a621ee8e9ac9a71da). You may have to wait a few minutes after your nodes are ready to login before the postboot script is fully executed.

When your nodes are ready, log in to "node-7". On this node, we also requested a publicly routable IP address. With a publicly routable IP, we can run a web server on the node that maps the Babel network from its point of view, and then view the map in a browser from any Internet-connected device.

On "node-7", run

```
git clone https://github.com/kerneis/babelweb.git
cd babelweb
sudo make install
```

Start the routing daemon, `babeld`, on "node-7" with

```
sudo babeld -g 33123 -D -d 1 -C 'redistribute local if eth0 deny' eth1 eth2
```

This tells Babel to distribute its routes for all interfaces excluding the control plan interface (`eth0`). Babel will regularly send messages to each of its direct neighbors:

* It periodically broadcasts Hello messages to all of its  neighbours, and periodically sends an IHU ("I Heard You") message to every neighbour from which it has recently heard a Hello. These messages are used to compute the cost between a node and its direct neighbors.
* It also periodically broadcasts route update messages to its neighbors. These messages essentially say, "Here are the destinations I can reach, and the cost at which I can reach them."

Finally, start `babelweb` on node-7:

```
babelweb
```

In the GENI Portal, click on the "Details" button on your slice page. Look for the hostname of "node-7":

![](/blog/content/images/2016/08/babel-hostname.png)

In the example above, it's `node-7.babel.ch-geni-net.instageni.umkc.edu`. In a browser, visit port 8080 on that URL (e.g. http://node-7.babel.ch-geni-net.instageni.umkc.edu:8080 in my example). There, you should see the Babel web display showing your node with no neighbors:

![](/blog/content/images/2016/08/babelweb-1.png)


Now, we'll start `babeld` on the rest of the topology. Log in to each of the other nodes, and run

```
sudo babeld -g 33123 -D -d 1 -C 'redistribute local if eth0 deny' eth1 eth2
```

Once information about all the destinations has propagated through the network, you should see all seven nodes on your babelweb display. Note that only the solid lines represent routes that are in use; the grey dashed lines represent routes that the node is aware of, but that are not installed. Thus, the network is loop free.

![](/blog/content/images/2016/08/babel-all.png)

Verify that you can reach all nodes from node-7. Use `mtr`, which shows you the IP address of every gateway that your messages go through, and ping each node by name, e.g.

```
mtr node-1
```

We have set the IP addresses on each interface so that the last octet of the IP address is the node number, to make it easier to follow paths through the network. Thus the following output

![](/blog/content/images/2016/08/babel-mtr.png)

shows that the path from node-7 to node-5 goes from node-7 to node-3 to node-4 to node-5.


Now, we'll verify that the routes are updated dynamically on changes in the topology. On node-7, bring down one interface:

```
sudo ifconfig eth1 down
```

In the babelweb interface, verify that new routes are found.

![](/blog/content/images/2016/08/babel-six-adjusted.png)

Use `mtr` again - have your routes changed? Are your messages passing through different gateways?

Note that in a distance-vector routing protocol like Babel, the node does not need to be aware of the entire topology. It only knows:

* its direct neighbors, and the cost to each of them, and
* further destinations that can be reached through its direct neighbors, and the cost to reach them that way - but not the entire path to those destinations.

Thus in the image above, we note that even destinations that are several hops away appears simply as "Others" attached to the neighbor through which the node will reach them. The source node does not know (or care) about the full path to these destinations.


Bring the interface back up with 

```
sudo ifconfig eth1 up
```

and verify that the more direct routes return.


When you're finished with the experiment, delete your resources in the GENI Portal to free them for other experimenters.